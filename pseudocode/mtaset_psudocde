abstract type Node 
keys: K[MAX_SIZE]
lock: MCSLock
size : int 
marked : bool 


type Leaf inherits Node 
vals : Value[ MAX_SIZE ] 
ver : int
left : leaf 
right : Leaf



type Internal inherits Node 
ptrs : Node [ MAX_SIZE ] 

type TaggedInternal inherits Internal 

type PathInfo 
gp : Node
p : Node 
pIdx : int
n : Node 
nIdx : int 

RetCode is SUCCESS or FAILURE or RETRY 

type entry : Internal 

<INT> findLatest(key, version, node)
  latestKeyIndex=-1
  latestVersionFound=-1
  latestInsertionTime=-1

  for i to MAX_SIZE-1
    if key = node.keys[i]
	    value = node.values[i]
	    if value = ⊥
	      continue
	    keyVersion = value.version
	    keyInserationTime = value.insertionTime
	
	    if keyVersion <= version AND keyVersion >= latestVersionFound AND keyInserationTime > latestInsertionTime
	      latestKeyIndex=i
	      latestVersionFound=keyVersion
	      latestInsertionTime=keyInserationTime

  return latestKeyIndex


<RetCode,V> searchLeaf(leaf,key)
RETRY:
  ver1 = leaf.ver
  if ver1 is odd
    goto RETRY

  latestIndex=findLatest(key, Integer.MAX_VALUE,leaf)
  value = ⊥
  value = leaf.values[latestIndex];
  ver2 = leaf.ver
  
  if ver2 is odd
    goto RETRY
  
  if value = ⊥
    return FAILURE, ⊥
  else
    return SUCCESS, value


PathInfo search(key,targetNode)
  gp=NULL,p=NULL,pIdx=0,n=entry,nIdx=0
  while n is not Leaf
    if n = targetNode 
	  break
    gp=p,p=n,pIdx=nIdx,nIdx=0
    while nIdx<node.size-1 AND key≥node.keys[nIdx]
      nIdx++
    n=n.ptrs[nIdx]
  return PathInfo(gp,p,pIdx,n,nIdx)


V find(key)
  pathInfo=search(key,NULL)
  rc,val=searchLeaf(pathInfo.n,key)
  return val


V insert(key,value)
  RETRY:
    path=search(key,NULL)
    rc,value=searchLeaf(path.n,key)
  
	  if rc=SUCCESS AND value != ⊥ OR rc=FAILURE AND value = ⊥
	    return value
	
    leaf,parent=path.n,path.p
    Lock leaf
    if leaf.marked
      Unlock leaf and goto RETRY
 
    // Verify key is not present
    for i = 0 to MAX_SIZE - 1
      if leaf.keys[i]=key
	      latestIndex=findLatest(key, Integer.MAX_VALUE,leaf)	
		    if node.values[latestIndex].value = ⊥ AND value != ⊥ OR node.values[latestIndex].value != ⊥ AND value = ⊥
			    break
        Unlock leaf and return leaf.vals[i]
  
    if leaf.size < MAX_SIZE
      // Insert without splitting
      for i = 0 to MAX_SIZE - 1
        if leaf.keys[i]=⊥
          leaf.ver++ // Start modification
		      val=new ValueCell(key,value,System.currentTimeMillis())
          leaf.keys[i]=key
          leaf.vals[i]=val
		      leaf.vals[i].casVersion(0, GLOBAL_VERSION.get());
          leaf.size++
          leaf.ver++ // End modification
          Unlock leaf and return ⊥
  
	  else
	    numberOfCleanedKey = cleanObsoleteKeys(leaf)
	    if numberOfCleanedKey > 0
	      write key,value to leaf
		    Unlock leaf
        fixUnderfull(leaf)
		    return value
        
	    Lock parent
        if parent.marked
          Unlock leaf and parent and goto RETRY
  
      N = { contents of leaf } U {key/val}
      initialize two leaf nodes, child1 and child2
      child1.right = child2
      child1.left = node.left
      child2.left = child1
      child2.right = node.right

      node.right.left = child2
      node.left.right = child1 



      newTaggedInternal = TaggedInternal with two child1 and child2 that evenly share N
      parent.ptrs[path.nIdx] = newTaggedInternal
      node.marked = true
      Unlock leaf and parent
      fixTagged(newLeaf)
      return ⊥


fixTagged(node)
  RETRY:
    if node.marked return
    path = search(node.searchKey,node)
    if path.n != node return
  
    Lock path.n, path.p, and path.gp
    if node , parent or gParent is marked or path.p is TaggedInternal
      Release all locks and goto RETRY
    
    node.marked = true
    path.p.marked = true
    if path.p.size + 1 <= MAX_NODE_SIZE
      newNode = new Internal containing the keys & pointers of node and parent
      path .gp. ptrs [ path . pIdx ] = newNode
      Release all locks
    else
      // newNode is a TaggedInternal , unless it will be the new root (in which case it is Internal )
      newNode = new subtree of three nodes consisting of a new Internal that points to two new internal nodes which evenly share the keys & pointers
                of node and parent ( except for the pointer to node )
      path.gp.ptrs[path.pIdx] = newNode
      Release all locks
      fixTagged(newNode)

fixUnderfull(node)
  if node=entry OR node=entry.ptrs[0] return
  
  RETRY:
    path=search(node.searchKey, node)
    if path.n != node return
  
    if path.nIdx = 0
      sIndex = 1 // Sibling is right child
    else
      sIndex = path.nIdx-1 
    sibling = parent.ptrs[sIndex]
  
    Lock node, sibling ,path.p, path.gp
    if node.size >= MIN_NODE_SIZE return
    if parent . size < MIN_NODE_SIZE or
       node , sibling , parent , or gParent is marked or
       node , sibling or parent is TaggedInternal
      Release all locks and goto RETRY
  
    if node.size + sibling.size <= 2 * MIN_NODE_SIZE
      newNode , sibling = Distribute keys of node and sibling evenly amongst new node and sibling
168 newParent = copy of parent plus pointer to newNode
and key between newNode and sibling
169 gParent . ptrs [ path . pIdx ] = newParent
170 Mark node , parent , and sibling
171 Release all locks and return
172 else
173 newNode = Combined keys of node and sibling
174 if gParent = entry and parent . size = 2
175 entry . ptrs [0] = newNode
176 Mark node , parent , and sibling
177 Release all locks and return
178 else
179 newParent = copy of parent with pointer to
newNode instead of node / sibling
180 path .gp. ptrs [ path . pIdx ] = newParent
181 Mark node , parent , and sibling
182 Release all locks
183 fixUnderfull ( newNode )
184 fixUnderfull ( newParent )