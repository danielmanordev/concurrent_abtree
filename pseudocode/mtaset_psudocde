abstract type Node 
keys: K[MAX_SIZE]
lock: MCSLock
size : int 
marked : bool 


type Leaf inherits Node 
vals : Value[ MAX_SIZE ] 
ver : int
left : leaf 
right : Leaf



type Internal inherits Node 
ptrs : Node [ MAX_SIZE ] 

type TaggedInternal inherits Internal 

type PathInfo 
gp : Node
p : Node 
pIdx : int
n : Node 
nIdx : int 

RetCode is SUCCESS or FAILURE or RETRY 

type entry : Internal

type ScanData {
    low: int
    high: int
    version: int
}

<INT> findLatest(key, version, node)
  latestKeyIndex=-1
  latestVersionFound=-1
  latestInsertionTime=-1

  for i to MAX_SIZE-1
    if key = node.keys[i]
	    value = node.values[i]
	    if value = ⊥
	      continue
	    keyVersion = value.version
	    keyInserationTime = value.insertionTime
	
	    if keyVersion <= version AND keyVersion >= latestVersionFound AND keyInserationTime > latestInsertionTime
	      latestKeyIndex=i
	      latestVersionFound=keyVersion
	      latestInsertionTime=keyInserationTime

  return latestKeyIndex


<RetCode,V> searchLeaf(leaf,key)
RETRY:
  ver1 = leaf.ver
  if ver1 is odd
    goto RETRY

  latestIndex=findLatest(key, Integer.MAX_VALUE,leaf)
  value = ⊥
  value = leaf.values[latestIndex];
  ver2 = leaf.ver
  
  if ver2 is odd
    goto RETRY
  
  if value = ⊥
    return FAILURE, ⊥
  else
    return SUCCESS, value


PathInfo search(key,targetNode)
  gp=NULL,p=NULL,pIdx=0,n=entry,nIdx=0
  while n is not Leaf
    if n = targetNode 
	  break
    gp=p,p=n,pIdx=nIdx,nIdx=0
    while nIdx<node.size-1 AND key≥node.keys[nIdx]
      nIdx++
    n=n.ptrs[nIdx]
  return PathInfo(gp,p,pIdx,n,nIdx)


V find(key)
  pathInfo=search(key,NULL)
  rc,val=searchLeaf(pathInfo.n,key)
  return val


V insert(key,value)
  RETRY:
    path=search(key,NULL)
    rc,value=searchLeaf(path.n,key)
  
	  if rc=SUCCESS AND value != ⊥ OR rc=FAILURE AND value = ⊥
	    return value
	
    leaf,parent=path.n,path.p
    Lock leaf
    if leaf.marked
      Unlock leaf and goto RETRY
 
    // Verify key is not present
    for i = 0 to MAX_SIZE - 1
      if leaf.keys[i]=key
	      latestIndex=findLatest(key, Integer.MAX_VALUE,leaf)	
		    if node.values[latestIndex].value = ⊥ AND value != ⊥ OR node.values[latestIndex].value != ⊥ AND value = ⊥
			    break
        Unlock leaf and return leaf.vals[i]
  
    if leaf.size < MAX_SIZE
      // Insert without splitting
      for i = 0 to MAX_SIZE - 1
        if leaf.keys[i]=⊥
          leaf.ver++ // Start modification
		  val=new ValueCell(key,value,System.currentTimeMillis())
          leaf.keys[i]=key
          leaf.vals[i]=val
		  leaf.vals[i].casVersion(0, GLOBAL_VERSION.get());
          leaf.size++
          leaf.ver++ // End modification
          Unlock leaf and return ⊥
  
	  else
	    numberOfCleanedKeys = cleanObsoleteKeys(leaf)
	    if numberOfCleanedKeys > 0
	      write key,value to leaf
		  Unlock leaf
          fixUnderfull(leaf)
		  return value
        
	    Lock parent
        if parent.marked
          Unlock leaf and parent and goto RETRY
  
        N = { contents of leaf } U {key/val}
        initialize two leaf nodes, child1 and child2
        child1.right = child2
        child1.left = node.left
        child2.left = child1
        child2.right = node.right

        node.right.left = child2
        node.left.right = child1



        newTaggedInternal = TaggedInternal with two children: child1 and child2 that evenly share N
        parent.ptrs[path.nIdx] = newTaggedInternal
        node.marked = true
        Unlock leaf and parent
        fixTagged(newTaggedInternal)
        return ⊥


fixTagged(node)
  RETRY:
    if node.marked return
    path = search(node.searchKey,node)
    if path.n != node return
  
    Lock path.n, path.p, and path.gp
    if node , parent or gParent is marked or path.p is TaggedInternal
      Release all locks and goto RETRY
    
    node.marked = true
    path.p.marked = true
    if path.p.size + 1 <= MAX_NODE_SIZE
      newNode = new Internal containing the keys & pointers of node and parent
      path .gp. ptrs [ path . pIdx ] = newNode
      Release all locks
    else
      // newNode is a TaggedInternal , unless it will be the new root (in which case it is Internal )
      newNode = new subtree of three nodes consisting of a new Internal that points to two new internal nodes which evenly share the keys & pointers
                of node and parent ( except for the pointer to node )
      path.gp.ptrs[path.pIdx] = newNode
      Release all locks
      fixTagged(newNode)



fixUnderfull(node)
  if node=entry OR node=entry.ptrs[0] return
  
  RETRY:
    path=search(node.searchKey, node)
    if path.n != node return

    Node right, left

    if path.nIdx = 0
      sIndex = 1 // Sibling is right child
      right = parent.ptrs[sIndex]
      left = path.n
    else
      sIndex = path.nIdx-1
      right = path.n
      left = parent.ptrs[sIndex]
    sibling = parent.ptrs[sIndex]
  
    Lock node, sibling ,path.p, path.gp
    if node.size >= MIN_NODE_SIZE return
    if parent.size < MIN_NODE_SIZE or
       node , sibling , parent , or gParent is marked or
       node , sibling or parent is TaggedInternal
      Release all locks and goto RETRY
  
    if node.size + sibling.size <= 2 * MIN_NODE_SIZE
      newNode , newSibling = Distribute keys of node and sibling evenly amongst newNode and newSibling
      newParent = copy of parent plus pointer to newNode and newSibling, and key between newNode and newSibling
      if node and sibling are leafs
        point newNode and newSibiling to each other, using the left and right pointers
        and connect newNode and newSibiling to the leafs linked-list using
        node and sibling and left and right pointers.

      gParent.ptrs[path.pIdx] = newParent
      Mark node , parent , and sibling
      Release all locks and return
    else
     newNode = Combined keys of node and sibling
     if newNode is leaf
       newNode.left = left.left
       newNode.right = right.right
       right.right.left = newNode
       left.left.right = newNode

     if gParent = entry and parent.size = 2
       entry.ptrs[0] = newNode
       Mark node , parent , and sibling
       Release all locks and return
     else
       newParent = copy of parent with pointer to newNode instead of node / sibling
       path.gp.ptrs[path.pIdx] = newParent
       Mark node , parent , and sibling
       Release all locks
       fixUnderfull(newNode)
       fixUnderfull(newParent)



INT Scan(low, high, entry, result)

1. Initialise ScanData and add it to ScanData array (publish)
2. Get and increment global version atomically
3. CAS the read version to ScanData and read version from ScanData to myVersion variable
4. Find the left most leaf that supposed to contain the low key, refer to it with leftNode variable
5. while true
  a. foreach key in leftNode:
     1. if key >= low and key <= high and keyVersion <= myVersion
        a. add key and value to local_array
     2. if key > high then continueToNextNode = false
  b. sort local_array by key, ascending order
  c. for each key in local_array
     1. find the key latest version and copy it to the result[] array
  d. if continueToNextNode && leftNode.right != null
     1. point to the right node: leftNode = leftNode.right
     else
       break
6. remove ScanData from the ScanData array
7. return the result[] array size

